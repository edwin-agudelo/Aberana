/*
 * File:   main.c
 * Author: Edwin
 *
 * Created on 12 de septiembre de 2022, 08:39 PM
 */


#include <xc.h>
#include <pic12f675.h>

// Fuse config
#pragma config FOSC=INTRCIO
#pragma config WDTE=OFF
#pragma config PWRTE=OFF
#pragma config MCLRE=OFF
#pragma config BOREN=OFF
#pragma config CP=OFF
#pragma config CPD=OFF

// Puertos
#define LUZI GPIObits.GP0
#define LUZD GPIObits.GP1
#define SND  GPIObits.GP2
#define INPL GPIObits.GP4
#define INPS GPIObits.GP5
// Banderas
#define LUZE 0  // Luz habilitada
#define SNDE 1  // Sonido habilitado
#define INP  2  // Entrada detectada, posible cambio
// Constantes
#define MAX_T 4096 // Maximo valor del contador para el tiempo de la luz

// Variables globales (registros)
unsigned char band;     // Almacena banderas
int cntluz;             // Contador de pulsos de luz
unsigned char cntsnd;   // Cuenta para frecuencia
int cntsndt;            // Contador de pulso para el tiempo del sonido
unsigned char ctmp;     // Variable temporal

// Definicion de funciones
void setup_clock(void);
void setup_io(void);
void setup_timer(void);
void prc_luz(void);
void prc_snd(void);
// Interupciones
void __interrupt() myISR(void);


void main(void) {
    
    // Inicializo banderas
    band = 0;
   
    // Setup the device
    setup_clock();
    setup_io();
    setup_timer();
    
    // Habilito las interrupciones 
    INTCONbits.GPIE = 1;
    INTCONbits.T0IE = 1;
    INTCONbits.GIE = 1;
    
    while(1){
        // No hago nada, todo está en las interrupciones
    }
    
    return;
}

void setup_clock(void) {
    asm("BSF STATUS,5"); // Bank 1
    asm("CALL 3FFh"); // Get the cal value
    asm("MOVWF OSCCAL"); // Calibrate
    asm("BCF STATUS,5"); // Bank 0
}

void setup_io(void) {
    GPIO = 0x0;
    ANSELbits.ANS = 0b00000000;
    CMCONbits.CM = 0x7;
    TRISIO = 0x30;
    LUZI = 0;
    LUZD = 0;
    IOCbits.IOC4 = 1; // Habilito los pines para la interrupcion
    IOCbits.IOC5 = 1;
}

void setup_timer(void) {
    OPTION_REGbits.T0CS = 0;
    OPTION_REGbits.PSA = 0;
    OPTION_REGbits.PS = 0x2;
}

void prc_luz(void) {
    LUZI = !LUZD;
    LUZD = LUZI;
    cntluz++;
    if(cntluz == MAX_T){
        LUZI = 0;
        LUZD = 0;
        band = band^(1<<LUZE);
    }
    return;
}

void prc_snd(void) {
    cntsnd++;
    if(cntsnd == 3) {
        SND = !SND;
        cntsnd = 0;
    }
    cntsndt++;
    if(cntsndt == MAX_T){
        SND = 0;
        band = band^(1<<SNDE);
    }
    return;
}

void __interrupt() myISR(void) {
    INTCONbits.GIE = 0;
    // check if the interrupt was generated by the timer0
    if(INTCONbits.T0IF){
        INTCONbits.T0IF = 0;
        if(band & (1<<LUZE)) {
            prc_luz();
        }
        if(band & (1<<SNDE)) {
            prc_snd();
        }
    }
    if(INTCONbits.GPIF){
        ctmp = GPIO;
        INTCONbits.GPIF = 0;
        if(INPL && !(band & (1<<LUZE))) {  // Luz
            cntluz = 0;
            band = band | (1<<LUZE);
        }
        if(INPS && !(band & (1<<SNDE))) {  // Sonido
            cntsnd = 0;
            cntsndt = 0;
            band = band | (1<<SNDE);
        }
    }
    INTCONbits.GIE = 1;
    return;
}

